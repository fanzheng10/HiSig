#' Retrieve the content of a gene set
#'
#' @param i The i-th gene set to probe.
#' @param design The design matrix.
#' @param array The gene-wise information. The order of genes should be the same as in the design matrix.
#' @return A vector containing the result.
#' @export
getterminfo <- function(i, design, array) {
  info = array[which(design[, i]!=0)]
  return(info)
}


#' Parse the HiSig results into a dataframe
#'
#' @param data A named list containing `design` and `response`.
#' @param impact The impact matrix; 1st column being the main fit; 2nd column to the end being the null model.
#' @param term.names a vector of term (gene set) names
#' @param gene.names a vector of gene names
#' @param signal2 if not NA, will print a second numerical information for gene sets. Default is NA.
#' @param gene.as.term if the design matrix sees individual gene as a gene set, set it to TRUE to correctly compute statistics. Default is FALSE.
#' @param showedge the number of top genes to print when the gene sets are big
#' @return A dataframe, sorted by q values.
#' @export
parse_hisig <- function(data, impact, term.names, gene.names, signal2=NA, gene.as.term=F, showedge=20) {

  data$response = round(data$response, 2)
  ngenes = length(gene.names)
  nterms = length(term.names)

  stopifnot(ngenes==length(data$response))
  # print(dim(data$design))
  term.sizes = Matrix::colSums(data$design!=0)

  # calculate p.values

  impact.main = impact[,1]
  impact.rand = impact[,2:dim(impact)[2]]
  pval <- rowSums(impact.rand > impact.main)/(dim(impact)[2]-1)
  qval = p.adjust(pval, method='BH')

  df = cbind(impact.main, pval, qval)
  df = round(df, 4)
  df = as.data.frame(df)
  names(df) = c("Selection.pressure", "p", "q")

  if (gene.as.term) {
    df = df[(ngenes+1):dim(impact)[1], ]
  }
  df$System.names = term.names
  nsys = dim(df)[1]

  # list the genes in the systems
  allranks = rank(-abs(data$response), ties.method = 'max')

  if (gene.as.term) {
    genesets = lapply(1:nsys, getterminfo, data$design[,(ngenes+1):dim(impact)[1]], gene.names)
    generanks = lapply(1:nsys, getterminfo, data$design[,(ngenes+1):dim(impact)[1]], allranks)
    signal1 = lapply(1:nsys, getterminfo, data$design[,(ngenes+1):dim(impact)[1]], data$response)
    term.sizes = term.sizes[(ngenes+1):dim(impact)[1]]
  }
  else {
    genesets = lapply(1:nsys, getterminfo, data$design, gene.names)
    generanks = lapply(1:nsys, getterminfo, data$design, allranks)
    signal1 = lapply(1:nsys, getterminfo, data$design, data$response)
  }
  gene_sort_ids = lapply(signal1, function(x) order(abs(x), decreasing=T)) # all sorted by signal1

  genesets_sorted = lapply(1:nsys, function(x) genesets[[x]][gene_sort_ids[[x]]] )
  generanks_sorted = lapply(1:nsys, function(x) generanks[[x]][gene_sort_ids[[x]]] )
  signal1_sorted = lapply(1:nsys, function(x) signal1[[x]][gene_sort_ids[[x]]] )

  genesets_sorted = as.character(lapply(genesets_sorted, function(x) paste(x[1:showedge][is.na(x[1:showedge])==F], collapse = '|')))
  generanks_sorted = as.character(lapply(generanks_sorted, function(x) paste(x[1:showedge][is.na(x[1:showedge])==F], collapse = '|')))
  signal1_sorted = as.character(lapply(signal1_sorted, function(x) paste(x[1:showedge][is.na(x[1:showedge])==F], collapse='|')))

  df$No.genes = term.sizes
  df$Genes = genesets_sorted
  df$Gene.ranks = generanks_sorted
  df$Signal = signal1_sorted

  if (is.na(signal2) ==F) {
    stopifnot(ngenes=length(signal2))
    if (gene.as.term) {
      signal2 = lapply(1:nsys, getterminfo, data = data$design[,(ngenes+1):dim(impact)[1]], array=signal2)
    }
    else {
      signal2 = lapply(1:nsys, getterminfo, data = data$design, array = signal2)

    }
    signal2_sorted = lapply(1:nsys, function(x) signal2[[x]][gene_sort_ids[[x]]] )
    signal2_sorted = as.character(lapply(signal2_sorted, function(x) paste(x[1:showedge], collapse='|')))
    df$Signal.2 = signal2_sorted
  }
  df <- df %>% filter(Selection.pressure > 0)
  df <- df %>% arrange(q, p, desc(Selection.pressure))

  return(df)
}

#' Parse HiSig results multi-sample mode
#
#' @param beta_sample An impact matrix (No. regulons x No. samples)
#' @param beta_null An impact matrix (No. r)
#' @return Two dataframes (No. regulons x No. samples). The first one for normalized scores, and the second one for q values. The normalized scores may contain 'NA'.
#' @export
parse_hisig_ms <- function(beta_sample, beta_null) {
  nsample = ncol(beta_sample)
  npermute = ncol(beta_null)
  p.vals <- sapply(1:nsample,
                   function(x) {rowSums(beta_null >= beta_sample[,x])/npermute})
  q.vals <- sapply(1:nsample,
                   function(x) {p.adjust(p.vals[,x], method ='BH')}) # TODO: think about it
  nes <- sapply(1:nsample,
                function(x) {npermute * beta_sample[,x]/rowSums(beta_null)})
  return(list(nes, q.vals))
}

#' Save the dataframe.
#'
#' @param df The dataframe generated by `parse_hisig`.
#' @param out The output filename.
#' @return
#' @export
output <- function(df, out) {
  colorder= c("System.names", "No.genes", "Selection.pressure", "p", "q", "Genes", "Gene.ranks", "Signal")
  if ("Signal.2" %in% names(df) ) {
    colorder = c(colorder, "Signal.2")
  }
  write.table(df[,colorder], file=out, quote=F, row.names = F, sep="\t")
}
