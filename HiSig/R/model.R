#' Load data for HiSig
#'
#' This function loads the design matrix and a response vector, the components
#' of a HiSig model. The rows and columns of the binary design matrix represent
#' genes and gene sets, respectively. If the element at (i, j) is 1, then the
#' i-th gene is a member of the j-th gene set
#' @param xfname A two column numerical file representing a sparse matrix. The
#'   1st/2nd dimension encodes the rows/columns of the binary design matrix.
#' @param yfname A numerical file containing the observed signal (response
#'   variable) for genes.
#' @param genes A vector of genes
#' @param terms A vector of gene sets
#' @return A list containing the `design`, `response`, `genes`, `terms` fields.
#' @export
load_data <- function(xfname, yfname, genes, terms, index1=T) { #TODO: making genes and terms accept file names too

  X <- as.matrix(read.table(xfname, header=F))

  if (dim(X)[2]==2) {
    X_sp = sparseMatrix(i=X[,1], j=X[,2], x=rep(1, dim(X)[1]), index1 = index1, dims=c(length(genes), length(terms)))
  }
  else {
    X_sp = sparseMatrix(i=X[,1], j=X[,2], x=X[,3], index1 = index1, dims=c(length(genes), length(terms)))
  }

  realy <- as.matrix(read.table(yfname, header=F))
  data <-list("design"=X_sp, "response"=realy, "genes"=genes, "terms"=terms)
  return(data)
}


#' Fit a linear model with glmnet.
#'
#' This function takes a "data" object (containing `design` and `response`), and
#' fit an entire lasso path. It generates a coefficient matrix of each gene set
#' at multiple sampled strengths of regularization (`lambda`).
#' @param data A named list containing `design` and `response`.
#' @param dummy A dummy variable for parallelzation. Default is 1.
#' @param random If TRUE, the fit is for the null model. Deactivate `lambda.min`
#'   and `nlambda`. Need to provide `lambda` value (generated by the main fit).
#'   Default is FALSE.
#' @param lambda.min A value for `lambda.min.ratio` variable of the `glmnet`
#'   function.
#' @param nlambda A value for `nlambda` variable of the `glmnet` function.
#' @param pos.only If TRUE, force all coefficients to be non-negative. Default
#'   is FALSE.
#' @param lambda Provide a vector of lambda when `random` is TRUE.
#' @return When `random` is TRUE, only return the `beta_max` vector (gene set
#'   impact on responses); when `random` is FALSE, return more details of the
#'   fit.
#' @export
hisig_fit <- function(data,
                      dummy = 1,
                      lambda.min = 0.0001,
                      nlambda = 100,
                      pos.only = F,
                      lambda = NULL,
                      random = F) {
  if (pos.only == F) {
    lower.limits = -Inf
  }
  else {
    lower.limits = 0
  }
  if (random) {
    stopifnot(is.null(lambda) == F)
    data$response <- sample(data$response)
    fit <- glmnet(data$design, data$response, lower.limits = lower.limits,
                  lambda = lambda,
                  standardize=F, family='gaussian')
  }
  else {
    fit <- glmnet(data$design, data$response, lower.limits = lower.limits,
                  lambda.min.ratio=lambda.min, nlambda=nlambda,
                  standardize=F, family='gaussian')
  }
  coef = as.matrix(fit$beta)
  coef = round(coef, digits=6)
  colnames(coef) = round(fit$lambda, digits = 9)

  coef = abs(coef)
  coef1 = coef[, abs(colSums(coef)) >0] #TODO: should distinguish sign better here
  norm_beta = scale(coef1, center=FALSE, scale=colSums(coef1) + abs(fit$a0[colSums(coef) >0]))
  beta_max = apply(norm_beta, 1, max)

  if (random) {
    return(beta_max)
  }
  else {
    out = list("beta.max"=beta_max, "coef"= coef1, "coef.norm" = norm_beta, "lambda" = fit$lambda)
    return(out)
  }
}

#' Create the HiSig null model with glmnet.
#'
#' @param data A named list containing `design` and `response`.
#' @param lambda An vector of lambda determined by the main fit.
#' @param batch Parameter of parallelization. The total number of permutatoin is `batch*batch_size`.
#' @param batch_size Parameter of parallelization
#' @param n_cores Number of cores to use for parallelization
#' @return A matrix to quantify the impact of gene sets under the null model.
#' @export
hisig_fit_rand <- function(data, lambda, batch=10, batch_size=10, n_cores=detectCores()-1) {
  for (i in 1:batch) {
    beta_max_all <- mclapply(1:batch_size, hisig_fit, data = data, lambda=lambda, random=T, mc.cores=n_cores, mc.cleanup=TRUE)
    if (i == 1) {
      beta_max_combined = as.data.frame(beta_max_all)
    }
    else {
      beta_max_combined = cbind(beta_max_combined, as.data.frame(beta_max_all))
    }
  }
  names(beta_max_combined) = 1:(batch*batch_size)
  return(beta_max_combined)
}
